# Lab1 实验报告

201908010703-计科1907 边英

## 一.练习

#### 1.练习1

1. #### 操作系统镜像文件ucore.img是如何一步一步生成的？

   1. 生成步骤

      - 整个原理及流程：make文件可以作为一个工程文件编译执行的调度器，大型工程包含若干源文件，之间调用关系十分复杂，你可以通过写一个makefile文件实现定义一些项目文件先进行编译，另一些后编译（其实就是模仿在命令行按顺序键入command命令）；除此之外还可以实现在某个项目文件更新的时候，make会自动建检测到是否有需要重新编译的项目文件，并对此进行更新。
      - 本实验设计了一个ucoreOS和一个软件bootloader用来加载ucoreOS。最终实现操作系统的启动，这些直接通过make命令实现（显然makefile里面规定了如何调用bootloader以及如何家在ucoreOS）

      - 可以通过make "V="先查看执行make文件的时候执行的操作（命令）

        可以看到编译,执行了一些.c程序，最后成功生成ucore.img镜像文件

        ![image-20211116162505874](/home/biang/.config/Typora/typora-user-images/image-20211116162505874.png)  

      - 阅读makefile文件查看一些语法定义以及生成整个流程

      1. <img src="/home/biang/.config/Typora/typora-user-images/image-20211116165139865.png" alt="image-20211116165139865" style="zoom:67%;" /> 

         > 创建kernel文件
         >
         > ld：链接文件
         >
         > -N 将文本和数据部分设置为可读和可写，不对数据段进行页面对齐
         >
         > -e: 设置一个显式的符号作为程序执行的入口
         >
         > -Ttext: 设置输出文件的文本段的起始地址
         >
         > -T: 显式的向链接器提供命令文件为（tools/kernel.ld）
         >
         > -S
         >
         > -t
         >
         > 编译链接生成kernel文件

      2. <img src="/home/biang/.config/Typora/typora-user-images/image-20211116164759710.png" alt="image-20211116164759710" style="zoom:67%;" /> 

         > 创建bootblock
         >
         > 先将 list_cc的bootfile.c都进行预处理，汇编，编译生成编译文件.o，然后将文件链接成可执行out文件bootblock
         >
         > 调用totarget函数传入sign进行处理，输出为bootblock文件

      3. <img src="/home/biang/.config/Typora/typora-user-images/image-20211116164906176.png" alt="image-20211116164906176" style="zoom:67%;" /> 

         > 创建sign工具
         >
         > 调用增添文件函数将sign.c加入host，并且传入参数sign，sign；
         >
         > 调用create_target_host文件，传入参数sign，sign

      4. <img src="/home/biang/.config/Typora/typora-user-images/image-20211116161403157.png" alt="image-20211116161403157" style="zoom:67%;" /> 

         > 创建ucore.img文件：
         >
         > 指定目标文件为UCOREIMG 源文件为调用totarget函数并且传参ucore.img
         >
         > dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。
         >
         > if=输入文件名（缺省就是指定的源文件）
         >
         > of=输入文件名（缺省为标准输出，指定的目标文件）
         >
         > count=size 指定拷贝大小为size的块
         >
         > conv=conversion 用指定的参数转换文件（notrunc：以不截断的形式转换文件）
         >
         > seek=size 跳过size个块之后再开始复制 
         >
         > 结果：
         >
         > dev/zero，bootblock，kernel写入UCOREIMG文件=》先初始化ucore.img为大小是10000个块，数据都为0，然后拷贝bootblock和kernel在其中
         >
         > 并且调用create_target函数，传入参数ucore.img
         >
         
      5. 编译链接生成kernel文件——编译链接bootblock——拷贝kernel，bootblock到ucore.img，生成ucore.img文件。

2. #### 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？

   ![image-20211116185658172](../../../../../../.config/Typora/typora-user-images/image-20211116185658172.png)

   看到命令行输入执行make时显示命令行时有这句创建空间成功，将bootblock加载到内存。makefile找到前后的代码，感觉和sign.c函数有关打开查看

   <img src="../../../../../../.config/Typora/typora-user-images/image-20211116190025976.png" alt="image-20211116190025976" style="zoom:50%;" /> 

   找到这一部分：

   显示说明sign.c函数规定了合法写入内存的要求：

   大小必须为512，且默认最后两位分别为0x55，0xAA。

   <img src="../../../../../../.config/Typora/typora-user-images/image-20211116185601716.png" alt="image-20211116185601716" style="zoom:67%;" /> 

#### 2.练习2

1. 为了熟悉使用qemu和gdb进行的调试工作，进行如下的小练习：

   1. #### 从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。

      先根据练习2的提示，在附录文件中查看单步调试bios的操作

      - 先保存gdbinit文件的副本，然后根据要求修改gdbinit文件

        ```
        set architecture i8086    //设置当前调试的CPU是8086
        target remote :1234       //通过端口1234与qeum连接
        ```
   
      - 在lab1的目录下输入
   
        ```
        make debug
        ```
   
        执行结果如下，发现成功启动qeum，并弹出终端![image-20211118172908097](../../../../../../.config/Typora/typora-user-images/image-20211118172908097.png)
   
        因为一开始修改初始文件删除了原本初始化文件的部分，造成初始化没有定位到文件位置，修改之后如下，正确显示定位的到kernel_init文件的开始位置
   
        ```
        file bin/kernel 
        target remote :1234
        set architecture i8086    
        break kern_init           //设置断点位置为
        continue                  //继续 ？
        ```
   
        ![image-20211118175021734](../../../../../../.config/Typora/typora-user-images/image-20211118175021734.png)
   
      - 在gdb内可以看到目前位于kernel_init的第一句代码的位置，输入si，单步执行操作，可以看到代码一步步执行指令
   
        <img src="../../../../../../.config/Typora/typora-user-images/image-20211118181643646.png" alt="image-20211118181643646" style="zoom:50%;" /> 
   
      - 
   
   2. #### 在初始化位置0x7c00设置实地址断点,测试断点正常。
   
      <img src="../../../../../../.config/Typora/typora-user-images/image-20211118193949221.png" alt="image-20211118193949221" style="zoom:67%;" />
   
      ​																	在debug命令框设置断点
   
      <img src="../../../../../../.config/Typora/typora-user-images/image-20211118194024057.png" alt="image-20211118194024057" style="zoom:67%;" />
   
      ​												查看断点表，有初始化断点和刚刚设置的断点
   
      断点设置成功，还有一种方式是修改kernel_init,将初始化断点由kernel_init改为0x7c00
   
      
   
   3. #### 从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。
   
      #### 操作指令：
   
      ```
      b *addr            //设置指定位置为断点
      info break         //查看断点信息
      x /ni $pc          //从pc开始查看n条指令
      set var $pc=addr   //设置地址为指定地址
      
      ```
   
      
   
      ```
      //bootasm.S
      
      #include <asm.h>
      
      # Start the CPU: switch to 32-bit protected mode, jump into C.
      # The BIOS loads this code from the first sector of the hard disk into
      # memory at physical address 0x7c00 and starts executing in real mode
      # with %cs=0 %ip=7c00.
      
      .set PROT_MODE_CSEG,        0x8                     # kernel code segment selector
      .set PROT_MODE_DSEG,        0x10                    # kernel data segment selector
      .set CR0_PE_ON,             0x1                     # protected mode enable flag
      
      # start address should be 0:7c00, in real mode, the beginning address of the running bootloader
      .globl start
      start:
      .code16                                             # Assemble for 16-bit mode
          cli                                             # Disable interrupts
          cld                                             # String operations increment
      
          # Set up the important data segment registers (DS, ES, SS).
          xorw %ax, %ax                                   # Segment number zero
          movw %ax, %ds                                   # -> Data Segment
          movw %ax, %es                                   # -> Extra Segment
          movw %ax, %ss                                   # -> Stack Segment
      
          # Enable A20:
          #  For backwards compatibility with the earliest PCs, physical
          #  address line 20 is tied low, so that addresses higher than
          #  1MB wrap around to zero by default. This code undoes this.
      seta20.1:
          inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
          testb $0x2, %al
          jnz seta20.1
      
          movb $0xd1, %al                                 # 0xd1 -> port 0x64
          outb %al, $0x64                                 # 0xd1 means: write data to 8042's P2 port
      
      seta20.2:
          inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
          testb $0x2, %al
          jnz seta20.2
      
          movb $0xdf, %al                                 # 0xdf -> port 0x60
          outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
      
          # Switch from real to protected mode, using a bootstrap GDT
          # and segment translation that makes virtual addresses
          # identical to physical addresses, so that the
          # effective memory map does not change during the switch.
          lgdt gdtdesc
          movl %cr0, %eax
          orl $CR0_PE_ON, %eax
          movl %eax, %cr0
      
          # Jump to next instruction, but in 32-bit code segment.
          # Switches processor into 32-bit mode.
          ljmp $PROT_MODE_CSEG, $protcseg
      
      .code32                                             # Assemble for 32-bit mode
      protcseg:
          # Set up the protected-mode data segment registers
          movw $PROT_MODE_DSEG, %ax                       # Our data segment selector
          movw %ax, %ds                                   # -> DS: Data Segment
          movw %ax, %es                                   # -> ES: Extra Segment
          movw %ax, %fs                                   # -> FS
          movw %ax, %gs                                   # -> GS
          movw %ax, %ss                                   # -> SS: Stack Segment
      
          # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)
          movl $0x0, %ebp
          movl $start, %esp
          call bootmain
      
          # If bootmain returns (it shouldn't), loop.
      spin:
          jmp spin
      
      # Bootstrap GDT
      .p2align 2                                          # force 4 byte alignment
      gdt:
          SEG_NULLASM                                     # null seg
          SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel
          SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel
      
      gdtdesc:
          .word 0x17                                      # sizeof(gdt) - 1
          .long gdt                                       # address gdt
      ```
   
      <img src="../../../../../../.config/Typora/typora-user-images/image-20211118200130046.png" alt="image-20211118200130046" style="zoom:67%;" />
   
      <img src="../../../../../../.config/Typora/typora-user-images/image-20211118193538837.png" alt="image-20211118193538837" style="zoom:67%;" />
   
      > 查看从pc开始的12条汇编语句，和bootasm.S语句进行比较，发现语句只是大致相同，具体不同：
      >
      > 1. bootasm.S是32为操作数。
      > 2. bootasm.S判等跳转语句通过jnz实现，而gdb反汇编是通过jne实现的。
      > 3. bootasm.S对应数据的地址都是逻辑地址，而gdb反汇编的语句都是物理地址。
      > 4. bootasm.S操作后都注明了操作位，gdb反汇编基本没有。
   
      ```
      //源代码过长截取部分：
      obj/bootblock.o：     文件格式 elf32-i386
      
      
      Disassembly of section .text:
      
      00007c00 <start>:
      
      # start address should be 0:7c00, in real mode, the beginning address of the running bootloader
      .globl start
      start:
      .code16                                             # Assemble for 16-bit mode
          cli                                             # Disable interrupts
          7c00:	fa                   	cli    
          cld                                             # String operations increment
          7c01:	fc                   	cld    
      
          # Set up the important data segment registers (DS, ES, SS).
          xorw %ax, %ax                                   # Segment number zero
          7c02:	31 c0                	xor    %eax,%eax
          movw %ax, %ds                                   # -> Data Segment
          7c04:	8e d8                	mov    %eax,%ds
          movw %ax, %es                                   # -> Extra Segment
          7c06:	8e c0                	mov    %eax,%es
          movw %ax, %ss                                   # -> Stack Segment
          7c08:	8e d0                	mov    %eax,%ss
      
      00007c0a <seta20.1>:
          # Enable A20:
          #  For backwards compatibility with the earliest PCs, physical
          #  address line 20 is tied low, so that addresses higher than
          #  1MB wrap around to zero by default. This code undoes this.
      seta20.1:
          inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
          7c0a:	e4 64                	in     $0x64,%al
          testb $0x2, %al
          7c0c:	a8 02                	test   $0x2,%al
          jnz seta20.1
          7c0e:	75 fa                	jne    7c0a <seta20.1>
      
          movb $0xd1, %al                                 # 0xd1 -> port 0x64
          7c10:	b0 d1                	mov    $0xd1,%al
          outb %al, $0x64                                 # 0xd1 means: write data to 8042's P2 port
          7c12:	e6 64                	out    %al,$0x64
      
      00007c14 <seta20.2>:
      
      seta20.2:
          inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
          7c14:	e4 64                	in     $0x64,%al
          testb $0x2, %al
          7c16:	a8 02                	test   $0x2,%al
          jnz seta20.2
          7c18:	75 fa                	jne    7c14 <seta20.2>
      
          movb $0xdf, %al                                 # 0xdf -> port 0x60
          7c1a:	b0 df                	mov    $0xdf,%al
          outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
          7c1c:	e6 60                	out    %al,$0x60
      
      
      ```
   
      ![image-20211118200600472](../../../../../../.config/Typora/typora-user-images/image-20211118200600472.png)
   
      > 对照观察gdb反汇编文件和bootblock.asm汇编格式可执行文件，发现对应物理地址，对应代码完全相同。
   
      
   
      <img src="../../../../../../.config/Typora/typora-user-images/image-20211118191438830.png" alt="image-20211118191438830" style="zoom:67%;" />
   
      <img src="../../../../../../.config/Typora/typora-user-images/image-20211118190643815.png" alt="image-20211118190643815" style="zoom:67%;" />
   
      <img src="../../../../../../.config/Typora/typora-user-images/image-20211118190722149.png" alt="image-20211118190722149" style="zoom:67%;" />
   
   4. #### 自己找一个bootloader或内核中的代码位置，设置断点并进行测试。
   
      <img src="../../../../../../.config/Typora/typora-user-images/image-20211118203514964.png" alt="image-20211118203514964" style="zoom:67%;" /> 
   
      设置断点为0x7c0c，更改pc的值，执行一次单步操作，正常执行，然后直接查看之后的10行命令，对照发现完全吻合，设置成功。
   
      <img src="../../../../../../.config/Typora/typora-user-images/image-20211118203913002.png" alt="image-20211118203913002" style="zoom: 50%;" /> 
   
      > 遇到的问题：
      >
      > 不可以显示执行的代码：应该是没有将相应反汇编文件加入
      >
      > 设置断点之后pc不跟随变化，只能显示出设置成功断点，但是pc不跳转还是上一次的pc值，只能手动更改
      >
      > remote 文件不支持run



#### 3.练习3

#### BIOS将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行bootloader。请分析bootloader是如何完成从实模式进入保护模式的。

状态寄存器（从64端口可以读取）：

<img src="../../../../../../.config/Typora/typora-user-images/image-20211119140117876.png" alt="image-20211119140117876" style="zoom:50%;" /> 

```
#include <asm.h> 

//设置代码段/数据段寄存器/保护模式开启

.set PROT_MODE_CSEG,        0x8                     # kernel code segment selector
.set PROT_MODE_DSEG,        0x10                    # kernel data segment selector
.set CR0_PE_ON,             0x1                     # protected mode enable flag 

//bootloader启动进入起始地址（0x7c00）
# start address should be 0:7c00, in real mode, the beginning address of the running bootloader               
.globl start
start:
.code16                                              # Assemble for 16-bit mode
    cli            //关闭中断                         # Disable interrupts
    cld            //清除方向                         # String operations increment
    
//设置寄存器清0  （0，数据，extra，栈）
    # Set up the important data segment registers (DS, ES, SS).
    xorw %ax, %ax                                   # Segment number zero
    movw %ax, %ds                                   # -> Data Segment
    movw %ax, %es                                   # -> Extra Segment
    movw %ax, %ss                                   # -> Stack Segment

    # Enable A20:
    #  For backwards compatibility with the earliest PCs, physical
    #  address line 20 is tied low, so that addresses higher than
    #  1MB wrap around to zero by default. This code undoes this.
    
//之前因为内存地址小，寄存器可访问空间大，为了配合只能用2^20部分的内存，设置了A20关门。现在可访问的内存空间地址变大，原本访问不了的地址可以访问了，而且在这个地方存放了实模式和保护模式下都可以访问的数据，这就要求我们无论实模式还是保护模式下都要将原本设置的这个门打开，让他可以正常访问到这段区域（原本设置的是直接将21位的地址位取0，相当于对超出去的地址取余，让他又回到0），现在关闭门的操作就是要将这个强制的0改掉：之前的控制理念是用8042单片机（自己拥有4个寄存器和2个端口<用于读写数据>，要操作的A20 Gate被定义在Output Port的bit 1上，操控其为1 ??  ）
seta20.1:                //等8042输入缓存为空
    inb $0x64, %al       //将64端口的数据给al 检测1bit是否为0，不等于0则继续循环检测，        
    testb $0x2, %al      
    jnz seta20.1

    movb $0xd1, %al      //向64端口写入数据11010001    # 0xd1 -> port 0x64
    outb %al, $0x64                                 # 0xd1 means: write data to 8042's P2 port

seta20.2:                //同上
    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
    testb $0x2, %al
    jnz seta20.2

    movb $0xdf, %al     //向60端口写入数据11011111    # 0xdf -> port 0x60
    outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1     

//加载全局描述符表，利用段地址映射机制访问物理内存
    lgdt gdtdesc
    
//用protected mode enable flag修改cro寄存器 ，将实模式转化为保护模式
    movl %cr0, %eax
    orl $CR0_PE_ON, %eax
    movl %eax, %cr0

//长跳转到32bit地址的指令，此时已经进入保护模式
    ljmp $PROT_MODE_CSEG, $protcseg

.code32                                             # Assemble for 32-bit mode
protcseg:
//设置保护模式（逻辑地址）下的数据段寄存器
    # Set up the protected-mode data segment registers
    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector
    movw %ax, %ds                                   # -> DS: Data Segment
    movw %ax, %es                                   # -> ES: Extra Segment
    movw %ax, %fs                                   # -> FS
    movw %ax, %gs                                   # -> GS
    movw %ax, %ss                                   # -> SS: Stack Segment

//设置保护模式（逻辑地址）下的栈底指针为0，栈顶指针为0x7c00
    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)
    movl $0x0, %ebp
    movl $start, %esp
    call bootmain   //跳转到bootmain函数入口

//如果bootmain不幸退出去（操作系统应该要一直运转）
    # If bootmain returns (it shouldn't), loop.
//就卡在spin这里
spin:
    jmp spin

//全局描述符定义
# Bootstrap GDT
.p2align 2                                          # force 4 byte alignment
gdt:
    SEG_NULLASM                                     # null seg
    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel
    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel

gdtdesc:
    .word 0x17             //全局描述符的表的大小      # sizeof(gdt) - 1
    .long gdt              //指向全局描述符的位置      # address gdt
```

阅读小节“保护模式和分段机制”和lab1/boot/bootasm.S源码，了解如何从实模式切换到保护模式，需要了解：

1. #### 为何开启A20，以及如何开启A20：

   > 因为地址线宽度增加，多出一部分实际上可以访问的到，但是为了兼容不想让他访问，这部分用来存放ROM和系统设备，但是要设计保护，可以锁起来也可以开启访问，所以设置了一个A20来控制是否可以访问。（实际上无论什么模式下都要打开）
   >
   > 通过读写端口设置8042单片机控制bit1位为1，打开A20；0，关闭A20

2. #### 如何初始化GDT表：

   > 直接加载
   >
   > lgdt gdtdesc

3. #### 如何使能和进入保护模式

   > 通过提前设定保护模式flag为1，通过这个flag修改cr0寄存器为1；
   >
   > 然后长跳转到32bit地址下的指令



#### 4.练习4

#### 通过阅读bootmain.c，了解bootloader如何加载ELF文件。通过分析源代码和通过qemu来运行并调试bootloader&OS，

```
#include <defs.h>
#include <x86.h>
#include <elf.h>

#define SECTSIZE        512                             //设置扇区大小为512
#define ELFHDR          ((struct elfhdr *)0x10000)      // scratch space

/* waitdisk - wait for disk ready */
//等待磁盘做好准备
static void
waitdisk(void) {
    while ((inb(0x1F7) & 0xC0) != 0x40)
        /* do nothing */;
}

//读取一个扇区的具体操作：读取扇区secno到dst
//1.等待磁盘做好准备
//2.发出读取扇区的命令
//3.等待磁盘准备好
//4.把磁盘扇区数据读到指定内存

/* readsect - read a single sector at @secno into @dst */
static void
readsect(void *dst, uint32_t secno) {       //传入目的内存地址和扇区号
    //先等磁盘就绪
    waitdisk();                             //等待扇区就绪
    
    //将端口输出指令（构造指令？）
    outb(0x1F2, 1);                         //表明读取1个扇区，count = 1
    outb(0x1F3, secno & 0xFF);              //将扇区号按字节输出，高四位设置为111x（表明是LBA模式：通过cpu访问硬件io地址寄存器）
    outb(0x1F4, (secno >> 8) & 0xFF);
    outb(0x1F5, (secno >> 16) & 0xFF);
    outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0);
    outb(0x1F7, 0x20);                      // 向端口输出指令0x20——读取指令 从1f0端口读取数据 

    waitdisk();                             //等待扇区就绪

    insl(0x1F0, dst, SECTSIZE / 4);         //在当0x1f7不为忙状态时执行读扇区操作到dst
    //从0x1f0读取SECTSIZE/4个双字到dst位置
    //注意这里是以双字为单位，即4个字节，所以才除以4，而且注意这里很多命令最后的“l”都对应了实际命令中的“d”
}

/* *
 * readseg - read @count bytes at @offset from kernel into virtual address @va,
 * might copy more than asked.
 * */
 //读取磁盘扇区  ？？？？？
 倒着开始读取
static void
readseg(uintptr_t va, uint32_t count, uint32_t offset) {   //传入参数：存放指定内存开始位置，读取长度？，偏移？
    uintptr_t end_va = va + count;       //求出结束位置

    // round down to sector boundary
    va -= offset % SECTSIZE;             //要读取的不足一个扇区

    // translate from bytes to sectors; kernel starts at sector 1
    uint32_t secno = (offset / SECTSIZE) + 1;

    for (; va < end_va; va += SECTSIZE, secno ++) {     //按扇区大小循环读取任意长度
        readsect((void *)va, secno);
    }
}

/* bootmain - the entry of bootloader */

void
bootmain(void) {
    // read the 1st page off disk
    
    //调用读取readseg函数读取数据内容
    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);

    //先判断是否是一个合法的ELFHDR：可以看到规定ELFHDR结构体里包含magic参数，规定必须等于define的ELF_MAGIC =0x464C457FU；不合法则跳转 执行outw(0x8A00, 0x8A00)2次，并且卡死
    if (ELFHDR->e_magic != ELF_MAGIC) {
        goto bad;
    }
    //定义程序头指针
    struct proghdr *ph, *eph;

    // load each program segment (ignores ph flags)
    //获取elf头在文件内的位置
    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);
    eph = ph + ELFHDR->e_phnum;
    for (; ph < eph; ph ++) {
        readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);
    }
    

    // 进入ELFHDR指明的可执行文件的入口
    ((void (*)(void))(ELFHDR->e_entry & 0xFFFFFF))();

bad:
    outw(0x8A00, 0x8A00);
    outw(0x8A00, 0x8E00);

    /* do nothing */
    while (1);
}

```

ELFheader：

<img src="../../../../../../.config/Typora/typora-user-images/image-20211119170422497.png" alt="image-20211119170422497" style="zoom:67%;" /> 

查看

1. #### bootloader如何读取硬盘扇区的？

   > 用LBA格式，传入端口数据读取指令，并将要读取的扇区号传送给硬盘的IO地址寄存器，设置好访问磁盘的模式，然后等磁盘空闲之后读取数据。
>
   > 1. 等待磁盘做好准备
   > 2. 发出读取扇区的命令
   > 3. 等待磁盘准备好
   > 4. 把磁盘扇区数据读到指定内存

2. #### bootloader是如何加载ELF格式的OS？

   > 1. 先判断elf头是否合法
   > 2. 将elf文件首地址传入读取函数？
   >
   
   

#### 5.练习5

#### 请完成实验，看看输出是否与上述显示大致一致，并解释最后一行各个数值的含义。

阅读小节“函数堆栈”，

1. 了解编译器如何建立函数调用关系的。在完成lab1编译后，查看lab1/obj/bootblock.asm，
2. 了解bootloader源码与机器码的语句和地址等的对应关系；查看lab1/obj/kernel.asm，
3. 了解 ucore OS源码与机器码的语句和地址等的对应关系。

#### 要求完成函数kern/debug/kdebug.c::print_stackframe的实现，提交改进后源代码包（可以编译执行），并在实验报告中简要说明实现过程，并写出对上述问题的回答。

> ##### 实现过程：
>
> 1.先了解栈帧结构：
>
> - 有关键寄存器
>
>   - ebp：存放栈底
>   - esp：存放栈顶
>   - eip：存放下一条指令的地址
>
> - 栈的生长方向：向低地址增长，栈顶位于低地址，栈底位于高地址
>
> - 栈的结构：
>
>   | Aebp      | oldebp(OS ebp) | 函数A的栈帧栈顶                           |
>   | --------- | -------------- | ----------------------------------------- |
>   |           | 局部变量       |                                           |
>   |           | ……             |                                           |
>   |           | B的传参2       |                                           |
>   |           | B的传参1       |                                           |
>   |           | *next order    | 调用函数B，先将调用之后的指令的地址压入栈 |
>   | Bebp      | Aebp           | 将A的旧ebp压入栈，令ebp=esp，esp扩充      |
>   |           | 函数B局部变量  |                                           |
>   |           | ……             |                                           |
>   |           | C的传参        |                                           |
>   | Besp👇     | *next order    |                                           |
>   | Cebp/Besp | Bebp           |                                           |
>
> - 函数调用时，栈帧的变化过程：
>
>   1. 每次在发生调用函数的时候：先将调用函数的传参放到栈顶（从后向前，确保第一个参数在栈顶）
>   2. 将调用之后的第一条指令的地址压入栈
>   3. 将当前函数栈帧的ebp（old ebp）压入栈
>   4. 将当前esp的值赋给ebp（地址内的值就是old ebp）
>   5. 新栈帧的esp扩充到栈顶
>
> 2.函数书写思路：
>
> 根据kdebug.c文件内的注释提示，以及结合实验报告要求：要求完成内容：
>
> 1. 利用函数读出ebp，eip的值
> 2. 从当前栈帧开始循环遍历，直至遍历空整个栈：
>    1. 打印出当前ebp，eip的值
>    2. 打印出*ebp+2这个地址内的值（对应）
>    3. 打印出当前eip的详细信息
>    4. 将当前栈帧弹出
>
> 3.遇到的问题
>
> 1. 不可以使用printf，只能使用cprintf
>
> 4.实验结果及验证
>
> ![image-20211120011826494](../../../../../../.config/Typora/typora-user-images/image-20211120011826494.png)
>
> ![image-20211120011927272](../../../../../../.config/Typora/typora-user-images/image-20211120011927272.png)
>
> 
>
> 5.最后一行数值的含义：
>
> ```
> ebp:7be8 , eip:10006a args:               //OS
>     kern/init/init.c:28: kern_init+105
> ebp:7bf8 , eip:7d71 args:                 //bootmain
>     <unknow>: -- 0x00007d70 --
> ```
>
> 截取了最后两次的循环加以说明，整个层次为：CPU上电->bios(bootloader)->os((kernel.init))->用户进程
>
> 因此最先看到的是用户进程read_eip，当一层层退出栈帧时，会退到最早的进程kernel.init，和最早压入栈的bootmain
>
> 在bootloader初始化栈的时候将ebp设为0，esp设为0x7c00，然后调用了bootmain，相当于压入一个地址之后将初始化的ebp0压入0x7bf8,然后bootmain的ebp为0x7bf8；之后加载OS，开辟栈帧，在OSebp的位置内存里记录的时bootmain的ebp0x7bf8……
>
> 因此在退出到OS这一层的时候（kernel_init），再退一层到达bootmain：其ebp为0x7b8f,再退一层就回到初始化的时候ebp=0
>
> <img src="../../../../../../.config/Typora/typora-user-images/image-20211120105522641.png" alt="image-20211120105522641" style="zoom:67%;" /> 



#### 6.练习6

1. #### 中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？

   <img src="../../../../../../.config/Typora/typora-user-images/image-20211120030740939.png" alt="image-20211120030740939"  /> 

   中断描述符表是映射异常和异常处理程序的映射表，每个表项储存的是某个中断对应的描述符（门，异常处理例程的相关信息）。IDT就是一个8字节的描述符数组。描述符index*8就是偏移量+IDT基址就是门所在的内存地址。

   ![image-20211120101312117](../../../../../../.config/Typora/typora-user-images/image-20211120101312117.png) 

   其中包含段选择子和偏移量offset，可以查询GDT确定例程所在段的信息（基地址+属性），从而得到中断服务例程起始地址。

   

2. ##### 请编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init。在idt_init函数中，依次对所有中断入口进行初始化。使用mmu.h中的SETGATE宏，填充idt数组内容。每个中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可。

   ![image-20211120112548510](../../../../../../.config/Typora/typora-user-images/image-20211120112548510.png)

3. ##### 请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。

   代码截图：

   

   <img src="../../../../../../.config/Typora/typora-user-images/image-20211120032840082.png" alt="image-20211120032840082" style="zoom: 67%;" /> 



## 二.实验主要内容

按题目5，6要求，完成代码书写部分，并完成验证回答问题。

1. ### challenge1

   ##### 增加一用户态函数（可执行一特定系统调用：获得时钟计数值），当内核初始完毕后，可从内核态返回到用户态的函数，而用户态的函数又通过系统调用得到内核态的服务。在 trap 里面处理 T_SWITCH_TO* 中断，并设置好返回的状态。

   在 lab1 里面完成代码以后，执行 make grade 评测结果是否正确。

   根据实验要求：

   - 书写一个用户态函数实现内核态的系统调用（init.c）
   - 书写一个可从内核态返回用户态的函数          (init.c)
   - 在 trap 里面处理 T_SWITCH_TO* 中断，设置好返回的状态 (trap.c)

   1. 用户态和内核态如何表示：cs寄存器低2位表示，00表示内核态，11表示用户态
   2. 

2. ### challenge2





